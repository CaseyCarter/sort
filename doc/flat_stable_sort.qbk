[/===========================================================================
 Copyright (c) 2017 Steven Ross, Francisco Tapia, Orson Peters


 Distributed under the Boost Software License, Version 1.0
 See accompanying file LICENSE_1_0.txt or copy at
 http://www.boost.org/LICENSE_1_0.txt
=============================================================================/]

[section:flat_stable_sort 2.4.- flat_stable_sort]

[*Flat_stable_sort] is a new stable sort algorithm, designed and implemented by Francisco Jose Tapia for the Boost Sort Library

The goal of the algorithm is provide a stable sort with a low additional memory (about 1% of the memory used by the data).

The stable sort algorithms provided by the compilers and libraries use an additional memory, usually of a half of the data to sort.

This new algorithm provide around 80%-90% of the speed of the spinsort and the stable sort algorithms provided by compilers and libraries.

The algorithm have an excellent response when the data are near sorted. Many times the new elements are inserted at end the sorted elements,
or some elements are modified, breaking the order of the elements. In these cases, the flat_stable_sort algorithm provide a very fast response.

You can see it in the results of the benchmarks in the  point 3.- Single Thread Benchmarks

[table AlgorithmDescription
[[Algorithm]            [Additional Memory]         [Best, average, and worst case]]
[[flat_stable sort]         [size of the data / 256 + 8K]   [N, NlogN , NlogN]]
]

This benchmarks sort 100 000 000 numbers of 64 bits

[table benchmark
[[Data] [std::stable_sort] [spin_sort] [flat_stable_sort]]
[[random]                    [ 8.62 ] [ 9.73 ] [10.80 ]]
[[sorted]                    [ 4.88 ] [ 0.06 ] [ 0.07 ]]
[[sorted + 0.1% end]         [ 4.92 ] [ 0.41 ] [ 0.36 ]]
[[sorted +   1% end]         [ 4.97 ] [ 0.55 ] [ 0.49 ]]
[[sorted +  10% end]         [ 5.73 ] [ 1.32 ] [ 1.40 ]]
[[sorted + 0.1% mid]         [ 6.58 ] [ 1.89 ] [ 2.61 ]]
[[sorted +   1% mid]         [ 7.06 ] [ 2.12 ] [ 3.07 ]]
[[sorted +  10% mid]         [ 9.56 ] [ 4.02 ] [ 5.49 ]]
[[reverse sorted]            [ 0.13 ] [ 0.14 ] [ 1.87 ]]
[[reverse sorted + 0.1% end] [ 5.22 ] [ 0.52 ] [ 0.42 ]]
[[reverse sorted +   1% end] [ 5.29 ] [ 0.66 ] [ 0.55 ]]
[[reverse sorted +  10% end] [ 6.03 ] [ 1.45 ] [ 1.44 ]]
[[reverse sorted + 0.1% mid] [ 6.52 ] [ 1.89 ] [ 2.54 ]]
[[reverse sorted +   1% mid] [ 7.09 ] [ 2.12 ] [ 3.09 ]]
[[reverse sorted +  10% mid] [ 9.46 ] [ 4.02 ] [ 5.53 ]]
]


Memory used by the stable sort algorithms measured on Linux x64

[table memory
[[Algorithm] [Memory used ( MB)] ]
[[std::stable_sort] [1177 MB] ]
[[spinsort]         [1175 MB] ]
[[flat_stable_sort] [ 788 MB] ]
[[spreadsort ]      [ 785 MB] ]
]



You only need to include the file boost/sort/parallel/sort.hpp

``
    #include <boost/sort/sort.hpp>


    template <class iter_t,  typename compare>
    void flat_stable_sort (iter_t first, iter_t last, compare comp = compare());
``

The spinsort function is in the namespace boost::sort

If you want a detailed information of this algorithm you can find in the [@./papers/flat_stable_sort_eng.pdf flat stable sort document]


Compiling this library requires a [*C++11 compliant compiler].

The algorithms use a [*comparison object], in the same way as the standard library sort
algorithms. If you don't define it, the comparison object defaults to std::less, which uses
the < operator internally for comparisons.

The algorithm is [*exception safe],  meaning that, the exceptions generated by the algorithms
guarantee the integrity of the objects to sort, but not their relative order. If the exception
is generated inside the objects (in the move or in the copy constructor.. ) the results can be
unpredictable.

[endsect]



