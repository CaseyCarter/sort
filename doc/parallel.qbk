[/===========================================================================
 Copyright (c) 2017 Steven Ross, Francisco Tapia, Orson Peters


 Distributed under the Boost Software License, Version 1.0
 See accompanying file LICENSE_1_0.txt or copy at
 http://www.boost.org/LICENSE_1_0.txt
=============================================================================/]

[section:parallel 3.- Parallel Algorithms]


The algorithms use a [*comparison object], in the same way as the standard library sort algorithms. If you don't define it,
the comparison object defaults to std::less, which uses the < operator internally for comparisons.

The algorithms are [*exception safe], meaning that, the exceptions generated by the algorithms guarantee the integrity
of the objects to sort, but not their relative order. If the exception is generated inside the objects (in the move or in the copy constructor.. ) the results can be unpredictable.

This table provides you a brief description of the sort algorithms in the library.

[table Parallel Algorithms
[[Algorithm][Stable][Additional memory][Best, average, and worst case]]
[[block_indirect_sort] [no] [block_size * num_threads][N LogN, N LogN , N LogN]]
[[sample_sort]         [yes][N]                       [N LogN, N LogN , N LogN]]
[[parallel_stable_sort][yes][N / 2]                   [N LogN, N LogN , N LogN]]
]

The block_size is an internal parameter of the algorithm, which in order to achieve the
highest speed, change according the size of the objects to sort according the next table.
[table BlockSize
[[object size (bytes)]              [1 - 15][16 - 31][32 - 63][64 - 127][128 - 255][256 - 511][512 -]]
[[block_size (number of elements)]  [4096]  [2048]      [1024][768][512][256][128]]
]

* Sample_sort is a implementation of the  [@ https://en.wikipedia.org/wiki/Samplesort Samplesort] algorithm done by Francisco Tapia.
* Parallel_stable_sort is based on the samplesort algorithm, but using a half of the memory used by sample_sort, ideated and implemented by Francisco Tapia.
* Block_indirect_sort is a novelty parallel sort algorithm, ideated and implemented by Francisco Tapia.

[*THREAD SPECIFICATION]

The parallel algorithms have a integer parameter indicating the number of thread to use in the sorting process,
which always is the last value in the call. The default value (if left unspecified) is the number of HW threads of
the machine where the program is running provided by std::thread::hardware_concurrency().

If the number is 1 or 0, the algorithm is done with only 1 thread.

The number of thread is not a fixed number, is calculate in each execution. The number of threads passed can be greater
than the number of HW threads in the HW.

We can pass 100 threads in a machine with 4 HW threads,
and in the same mode we can pass a function as (std::thread::hardware_concurrency() / 4 ). If this value is 0, the program is executed with 1 thread

You only need to include the file boost/sort/parallel/sort.hpp

``
    #include <boost/sort/sort.hpp>
``

The parallel algorithms have 4 invocation formats:

``
[^teletype]
    algorithm ( first iterator, last iterator, comparison object, number of threads )
    algorithm ( first iterator, last iterator, comparison object )
    algorithm ( first iterator, last iterator, number of threads )
    algorithm ( first iterator, last iterator )
``

All the algorithms are in the namespace boost::sort

If no comparison object is specified, the default class ( std::less<value_t> ) is used.

If the number of threads is unspecified, the number of HW threads on the machine where the the program is running is used


[include block_indirect_sort.qbk]
[include sample_sort.qbk]
[include parallel_stable_sort.qbk]
[include linux_parallel.qbk]
[include windows_parallel.qbk]
[endsect]



