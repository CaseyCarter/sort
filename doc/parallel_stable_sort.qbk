[/===========================================================================
 Copyright (c) 2017 Steven Ross, Francisco Tapia, Orson Peters


 Distributed under the Boost Software License, Version 1.0
 See accompanying file LICENSE_1_0.txt or copy at
 http://www.boost.org/LICENSE_1_0.txt
=============================================================================/]

[section:parallel_stable_sort 3.3.- Parallel_stable_sort]

[:
This algorithm is based on the [*[@ https://en.wikipedia.org/wiki/Samplesort Samplesort]] algorithm, but uses half of the memory used by samplesort.

The design and implementation are done by Francisco Tapia for the Boost Library.

[h4[_Algorithm Description]]
[:
[*[teletype]
``
                          |       |                        |                              |
    Algorithm             |Stable |   Additional memory    |Best, average, and worst case |
    ----------------------+-------+------------------------+------------------------------+
    parallel_stable_sort  |  yes  |        N / 2           |     N, N LogN , N LogN       |
                          |       |                        |                              |
``
]

You can see their performance in the [*[link sort.parallel.linux_parallel Benchmarks]] chapter
]

[h4[_Thread specification]]

[:
This algorithm have a integer parameter indicating the *number of thread* to use in the sorting process,
which always is the last value in the call.

The default value (if left unspecified) is the number of HW threads of
the machine where the program is running provided by std::thread::hardware_concurrency().
If the number is 1 or 0, the algorithm runs with only 1 thread.

The number of threads is not a fixed number, but is calculated in each execution. The number of threads passed can be greater
than the number of hardware threads on the machine. We can pass 100 threads in a machine with 4 HW threads,
and in the same mode we can pass a function as (std::thread::hardware_concurrency() / 4 ).
If this value is 0, the program is executed with 1 thread.

]


[h4[_Programming]]
[:
Only need to include the file boost/sort/sort.hpp.

The algorithm run in the namespace boost::sort

[c++]
``
    #include <boost/sort/sort.hpp>


    template <class iter_t>
    void parallel_stable_sort (iter_t first, iter_t last);

    template <class iter_t,  typename compare>
    void parallel_stable_sort (iter_t first, iter_t last, compare comp);

    template <class iter_t>
    void parallel_stable_sort (iter_t first, iter_t last, uint32_t num_thread);

    template <class iter_t,  typename compare>
    void parallel_stable_sort (iter_t first, iter_t last, compare comp, uint32_t num_thread);

``

This algorithm need a *C++11 compliant compiler*. Don't need any other code or library. With older compilers it is not guarantee, the correct operation.

If the number of threads is unspecified, use the result of std::thread::hardware_concurrency()

The algorithm use a *comparison object*, in the same way as the standard library sort
algorithms. If don't define, the comparison object is std::less, which uses internally
the < operator.

The algorithm is [*exception safe],  meaning that, the exceptions generated by the algorithm
guarantee the integrity of the objects to sort, but not their relative order. If the exception
is generated inside the objects (in the move or in the copy constructor.. ) the results can be
unpredictable.
]
]

[endsect]



