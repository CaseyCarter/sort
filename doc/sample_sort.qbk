[/===========================================================================
 Copyright (c) 2017 Steven Ross, Francisco Tapia, Orson Peters


 Distributed under the Boost Software License, Version 1.0
 See accompanying file LICENSE_1_0.txt or copy at
 http://www.boost.org/LICENSE_1_0.txt
=============================================================================/]

[section:sample_sort 3.2- Sample_Sort]

This is a implementation of the  [@https://en.wikipedia.org/wiki/Samplesort Samplesort] algorithm by Francisco Tapia for the Boost Library.

[table AlgorithmDescription
[[Algorithm]            [Parallel]  [Stable][Additional Memory]         [Best, average, and worst case]]
[[sample_sort]          [Yes]       [Yes]   [N]                         [N, NlogN , NlogN]]
]

This algorithms [*do not use any other library or utility]. Compiling this library requires a
[*C++11 compliant compiler]. There is no need to link with any external static or dynamic library.

The algorithms use a [*comparison object], in the same way as the standard library sort
algorithms. If you don't define it, the comparison object defaults to std::less, which uses
the < operator internally for comparisons.
If no comparison object is specified, the default class ( std::less<value_t> ) is used.


The algorithms are [*exception safe],  meaning that, the exceptions generated by the algorithms
guarantee the integrity of the objects to sort, but not their relative order. If the exception
is generated inside the objects (in the move or copy constructors) the results are undefined.



You only need to include the file boost/sort/parallel/sort.hpp to use sample_sort

``
    #include <boost/sort/sort.hpp>


    template <class iter_t>
    void sample_sort (iter_t first, iter_t last);

    template <class iter_t,  typename compare>
    void sample_sort (iter_t first, iter_t last, compare comp);

    template <class iter_t>
    void sample_sort (iter_t first, iter_t last, uint32_t num_thread);

    template <class iter_t,  typename compare>
    void sample_sort (iter_t first, iter_t last, compare comp, uint32_t num_thread);

``
This algorithm is in the namespace boost::sort

This is a parallel stable sort algorithm. It is faster than parallel_stable_sort but the auxiliary memory used is N elements.
You can see the details in the benchmark chapter.


[endsect]



